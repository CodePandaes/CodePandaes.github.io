{"pages":[],"posts":[{"title":"hexo设置icarus主题","text":"上篇博文只是简单搭建起来了Hexo博客，现在来设置主要配置信息和修改主题icarus Hexo配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# Sitetitle: #主页标题subtitle: #副标题description: #网站描述description主要用于SEOkeywords: #博客关键字author: #作者，左下角显示language: zh_Hans # 选择中文简体timezone: 'Asia/Shanghai' #时区:国内选择上海# Urlurl: http://yoursite.com #填自己的github pages网址 root: / #网站根目录permalink: :year/:month/:day/:title/ #文章的 永久链接 格式permalink_defaults: #永久链接中各部分的默认值pretty_urls: #改写 permalink 的值来美化 URLtrailing_index: false # 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html 是否在 永久链接中保留尾部的 index.html，设置为 false 时去除trailing_html: true #是否在永久链接中保留尾部.html, 设置为 false 时去除# Directorysource_dir: source #资源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code 文件夹，source_dir 下的子目录i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可 使用 glob 表达式来匹配路径。# Writingnew_post_name: :year-:month-:day-:title.md #生成yyyy-MM-dd-博文名称的名称有助于我们管理自己的博 文。 default_layout: post #预设布局titlecase: false #把标题转换为 title caseexternal_link: #在新标签中打开链接 enable: true #在新标签中打开链接 field: site #对整个网站（site）生效或仅对文章（post）生效 exclude: '' #需要排除的域名。主域名和子域名如 www 需分别配置filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #显示草稿post_asset_folder: false #启动 Asset 文件夹 new 文件的同时，xxxx.md文件还有一个同名的文件夹relative_link: false #把链接改为与根目录的相对位址future: true #显示未来的文章highlight: enable: true #开启代码块高亮 line_number: true #显示行数 auto_detect: false #如果未指定语言，则启用自动检测 tab_replace: '' #用 n 个空格替换 tabs；如果值为空，则不会替换 tabs wrap: true # 将代码块包装到&lt;table&gt; hljs: false # CSS类使用hljs-*前缀# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date# Category &amp; Tagdefault_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Metadata elementsmeta_generator: true # Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签# Date / Time format## Hexo uses Moment.js to parse and display date Hexo 使用 Moment.js 来解析和显示时间## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD #日期格式time_format: HH:mm:ss #时间格式use_date_for_updated: false #启用以后，如果Front Matter中没有指定 updated， post.updated 将会使用date的值而不是文件的创建时间。在Git工作流中这个选项会很有用# Pagination## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page #分页目录# Include / Exclude file(s)## include:/exclude: options only apply to the 'source/' folderinclude: #Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和 _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。exclude: #Hexo 会忽略这些文件和目录ignore: #Ignore files/folders# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus #当前主题名称。值为false时禁用主题# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: #部署部分的设置 type: git repo: https://github.com/CodePandaes/CodePandaes.github.io.git #github中仓库地址 branch: master 替换icarus主题icarus这个主题比较小众，个人也很喜欢这个主题yilia，或者选择官方主题，打开git bash下载主题icarus 12$ cd /d/WorkPlace/myHexo$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 下载好的主题在themes文件夹下 修改配置文件完成后，git bash中执行命令hexo clean(清除缓存文件)，然后执行hexo g 和hexo s 重新发布 1theme: icarus #在Hexo配置文件中把landscape切换为icarus icarus配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160version: 2.6.0 #版本favicon: /images/panda.ico #浏览器图标meta: # Additional HTML meta tags in an array.canonical_url: # canonical_url of your siterss: # Path or URL to RSS atom.xmllogo: /images/logo.ico #logo# Open Graph metadata# https://hexo.io/docs/helpers.html#open-graphopen_graph: # Facebook App ID fb_app_id: # Facebook Admin ID fb_admins: # Twitter ID twitter_id: # Twitter site twitter_site: # Google+ profile link google_plus: navbar: # 导航栏 # 菜单（显示名称：对应文件夹） menu: 主页: / 归档: /archives 分类: /categories 标签: /tags 关于我: /about # github账号 links: Download on GitHub: icon: fab fa-github url: 'https://github.com/ppoffice/hexo-theme-icarus'# 页脚图标链接footer: # Links to be shown on the right of the footer section links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'https://github.com/ppoffice/hexo-theme-icarus'# 文章显示设置article: # Code highlight settings highlight: theme: atom-one-light # 代码主题atom-one-light亮色，atom-one-dark暗色 clipboard: true # 显示代码copy按钮 # Default folding status of the code blocks. Can be \"\", \"folded\", \"unfolded\" fold: unfolded thumbnail: true # 是否显示文章主图 readtime: true # 是否显示估算阅读时间# Search plugin settings 搜索插件设置search: type: insight # 插件名# 评论插件设置comment: #可选valine，disqus（科学上网）等 # Name of the comment plugin #type: valine #app_id: 不为空 #app_key: 不为空 #notify: true #verify: true #placeholder: # Name of the comment plugin type: # Donation entries 打赏功能donate: - type: alipay # 支付宝 qrcode: '/' # 支付宝图片URL - type: alipay # 微信 qrcode: '/' # 微信图片URL -# 分享插件设置share: # Share plugin name 插件类型，有多种，可选，自行百度 type: # Sidebar settings.sidebar: # left sidebar settings 左侧边栏设置 left: # 是否不随页面滚动 sticky: true # right sidebar settings 右侧边栏设置 right: sticky: false# Sidebar widget settings 边栏小部件设置widgets: - type: profile # 个人信息 position: left # 部件位置（左） author: 程序熊猫 # 作者名（字符串） author_title: Developer #作者身份描述（字符串） location: 湖北·武汉 #作者当前居住地 avatar: '/images/touXiang.jpeg' #头像（可用本地图片或网络图片链接） gravatar: # 要在配置文件小部件中显示的Gravatar的电子邮件地址 avatar_rounded: false #显示圆形或方形的化身图像 follow_link: 'https://github.com/CodePandaes' #关注我的链接，可设为你的GitHub主页 #个人介绍部件底部图标社交链接 social_links: Github: icon: fab fa-github url: 'https://github.com/CodePandaes' Facebook: icon: fab fa-facebook url: 'https://facebook.com' # Twitter: # icon: fab fa-twitter # url: 'https://twitter.com' # Dribbble: # icon: fab fa-dribbble # url: 'https://dribbble.com' # RSS: # icon: fas fa-rss # url: / - # Widget name 组件toc type: toc # Where should the widget be placed, left or right position: left - # Widget name 标签 type: tag # Where should the widget be placed, left or right position: right - # Widget name 分类 type: category # Where should the widget be placed, left or right position: right - # Widget name 标签云 type: tagcloud # Where should the widget be placed, left or right position: right - # Widget name 近期文章 type: recent_posts # Where should the widget be placed, left or right position: left - # Widget name 归档 type: archive # Where should the widget be placed, left or right position: right - # Widget name 外部链接 type: links # Where should the widget be placed, left or right position: right # Links to be shown in the links widget links: 阮一峰的博客: 'http://www.ruanyifeng.com/blog' 廖雪峰的博客: 'http://www.liaoxuefeng.com'","link":"/2020/03/06/hexo%E4%B8%BB%E9%A2%98icarus%E8%AE%BE%E7%BD%AE%E5%92%8Chexo%E8%AE%BE%E7%BD%AE/"},{"title":"hexo初体验-搭建博客教程","text":"使用Hexo + Github的方式免费搭建自己的个人博客 一.环境 node.js, npm github账号 git 二.搭建 新建一个以你的github用户名为名字的仓库，等会把Hexo博客部署到github上之后就可以通过你的用户名.github.io访问你的个人博客啦 打开git bash输入命令npm install -g hexo 安装Hexo 新建文件夹myHexo(名字任取，用来放Hexo博客相关文件)，并进入myHexo，输入命令hexo init，初始化成功后看到提示start blogging with hexo即成功，hexo会自动下载一些文件到这个目录，包括node_modules.(后续哪一步出错可以直接删掉myHexo文件夹再一次执行以上操作) 输入命令hexo g 生成静态文件，然后输入hexo s 开启本地预览服务，启动hexo博客，端口为4000，浏览器中输入localhost:4000即可打开博客，ctrl + c 关闭 先进github复制仓库地址，再打开_config.yml配置文件，找到deploy相关设置，按如下配置 输入命令hexo d 推送到远端，输入github账号，密码(可提前设置sshkey)部署完成。然后通过你的用户名.github.io访问你的个人博客，此时博客就已经初步搭建好了 如果你不满意主题，请移步hexo设置icarus主题","link":"/2020/03/06/hexo%E5%88%9D%E4%BD%93%E9%AA%8C-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"},{"title":"hexo常用的插件配置","text":"常用插件（icarus主题）：来必力评论插件，百度统计插件，bdshare分享插件 来必力 先去来必力官网注册Livere账号，然后选择City免费版本，点击安装，在右上角管理页面中设置你的来必力名称和网站地址，生成安装代码，获取data-uid 复制data-uid，打开主题icarus的配置文件_config.yml，找到comment评论插件设置type和uid，完成后执行命令hexo clean（清除缓存文件），然后执行hexo g（生成静态文件） 和hexo s （启动本地预览）,效果如下 回到来必力开启邮件提醒和设置评论登录平台 百度统计 进入百度统计官网注册账号，登录控制台添加自己的博客地址，然后复制统计代码和hm.js后面的id 找到icarus配置文件_config.yml中的baidu-analytics下的tracking_id属性，把hm.js后面的id粘贴过去，再找到主题中对应的footer.ejs或其他主题的footer模板，再把统计代码复制到footer.ejs中，达到一处安装，全站皆有的效果，完成后执行命令hexo clean，hexo g和hexo s，最后hexo d部署到远端 检查代码是否安装成功 打开代码安装自动检查是否成功 或者直接打开基础报告查看是否有访问数据，有则说明成功 或者打开你的博客，F12点击Network，然后F5刷新看到hm.js加载则说明安装成功 bdshare分享插件打开icarus主题配置文件_config.yml找到share，设置type为bdshare，刷新即生效，或者选择其他插件如：share.js，addtoany等，效果如下","link":"/2020/03/07/hexo%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/"},{"title":"SpringBoot中@SpringBootApplication注解解析","text":"为什么SpringBoot项目添加一个简简单单的注释就能实现诸多功能呢 SpringBootApplication解密SpringBoot 2.0.6 版本为例 12345678910111213141516@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class}), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class})})public @interface SpringBootApplication {} @Target({ElementType.TYPE})：指明了修饰的这个注解的使用范围为类，接口或者枚举 @Retention(RetentionPolicy.RUNTIME)：指明修饰的注解的生存周期为运行级别保留，编译后的class文件中存在，在jvm运行时保留，可以被反射调用。 @Documented：指明修饰的注解，可以被例如javadoc此类的工具文档化 @Inherited：允许子类继承父类中的注解 @interface意思是声明一个注解，方法名对应参数名，返回值类型对应参数类型。接下来的三个注解才是重中之重 @SpringBootConfiguration点进去查看代码，发现@Configuration注解，原来是spring全家桶时代的注解，作用是申明一个配置类 123456@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration {} @Configuration点进去发现是@Component注解的实现，而@Component意思是把当前的配置类添加到spring容器中，表示是一个组件 12345678910@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Configuration { @AliasFor( annotation = Component.class ) String value() default &quot;&quot;;} 所以这个注解没什么新东西 @ComponentScan这个注解的主要作用就是，被该注解标识的类会被Spring的IOC容器纳入管理，比如@Controller，@Service，@Repository注解，查看其源码你会发现，他们中有一个共同的注解@Component，所以被它们注解的类会被Spring的IOC容器纳入管理 excludeFilters：按照规则排除某些包的扫描 includeFilters：按照规则只包含某些包的扫描也没啥新东西，权当复习 3.@EnableAutoConfiguration@EnableAutoConfiguration的作用是启动自动配置，意思是Spring Boot会根据你添加的jar包来配置你项目的默认设置，比如你添加了Spring Boot提供的spring-boot-starter-web依赖，其中包含了Tomcat和Spring MVC，这个注释就会认为你正在开发一个Web应用程序，自动地帮你添加Web项目中所需要的Spring配置。点进去查看代码，分析具体实现 12345678910111213@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import({AutoConfigurationImportSelector.class})public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;; Class&lt;?&gt;[] exclude() default {}; String[] excludeName() default {};} @AutoConfigurationPackage：自动配置包@Import({AutoConfigurationImportSelector.class})：它会把项目里面所有需要导入的组件以全类名的方式返回，将这些组件添加到容器中。而且会给容器中注入非常多的自动配置类，导入并配置好当前项目中所需要的组件。这是如何实现的呢？进入AutoConfigurationImportSelector.class找到selectImports（）方法里面的getCandidateConfigurations（）方法 然后进入getCandidateConfigurations方法找到loadFactoryNames方法，再进入loadFactoryNames方法找到loadSpringFactories（），里面有这段代码classLoader.getResources(“META-INF/spring.factories”)，表示去META-INF/spring.factories中寻找需要加载的自动配置类（xxxAutoConfiguration） 可以看到spring.factories中有很多以xxxAutoConfiguration命名的配置类包括CacheAutoConfiguration和RabbitAutoConfiguration","link":"/2020/03/11/SpringBoot%E4%B8%AD-SpringBootApplication%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90/"},{"title":"SpringBoot初体验","text":"SpringBoot零基础上手体验 简介在“Spring全家桶”时代，J2EE笨重的开发，繁多的配置，部署过程的繁琐以及大难度的第三方集成都给作为程序员的我们带来了极大的麻烦，于是在Spring的基础上应运而生了SpringBoot框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程，实现J2EE的一站式解决。 特点 使用 Spring 项目引导页面可以在几秒构建一个项目 应用直接打包成war包 约定大于配置，可以使用默认配置，但通过自己设置参数，即可摆脱这种方式 starter启动器自动依赖，监听，事物，连接池等都有集成好的starter直接使用 无需配置xml，无代码生成，开箱即用 版本解读打开SpringBoot官网看到如下版本，建议使用GA版本 GA:General Availability,正式发布的版本，官方推荐使用此版本。在国外都是用GA来说明release版本的。 PRE: 预览版,内部测试版. 主要是给开发人员和测试人员测试和找BUG用的，不建议使用； SNAPSHOT: 快照版，可以稳定使用，且仍在继续改进版本 快速搭建环境准备： IDEA2018 windows7打开IDEA，new一个project，选择Spring Initializr（用来初始化一个Spring boot 的项目），不用手动添加web依赖包，选择组件即可 填写项目坐标 添加web组件 填写项目名finish 打开pom.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.study.helloword&lt;/groupId&gt; &lt;artifactId&gt;study-helloword&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt;&lt;!-- 这是Spring Boot的父级依赖，用来提供相关的Maven默认依赖。使用它之后，常用的包依赖可以省去version标签。 --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;&lt;!-- 可以选择2.1.13或者2.25版本 --&gt; &lt;/parent&gt; &lt;dependencies&gt;&lt;!-- 自动生成web依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；无需在应用服务器安装tomcat--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 编写HelloWorldController 打开启动类HelloWorldMainApplication，点击run启动项目 localhost:8080/hello访问成功 至此一个简单的springboot项目就搭建起来了。","link":"/2020/03/11/SpringBoot%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"title":"SpringBoot实现热部署","text":"现在有了spring-boot-devtools启动器，能在SpringBoot的web开发中实现热部署 在实际开发过程中，每次修改后台代码就必须要重启来保证源代码或者配置文件的生效，特别是当下微服务开发火热，动不动同时启动多个微服务，debug一次耗时又费力，现在有了spring-boot-devtools启动器，能在SpringBoot的web开发中实现热部署，以下以IDEA为例其原理就是监听classpath路径下的文件变动，修改代码，立即重启.。 配置 IDEA中默认是不自动编译的，左上角打开setting设置Build project automatically自动编译功能 ctrl + shift + alt + /,选择Registry,勾上 Compiler autoMake allow when app running 打开pom.xml引入依赖123456789101112131415161718&lt;!--实现工程热部署，修改代码不需要重启服务器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;!--依赖不会传递，该项目依赖devtools；之后依赖此项目的项目如果想要使用devtools，需要重新引入--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;!-- 如果没有该配置，devtools不会生效 --&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 启动项目，控制台确实显示devtools在监听classpath路径下的文件变动 修改UserController下的代码，发现console确实重启了项目，实现了热部署 ​ devtools也可以单独监控某个文件夹下的文件，如： 123devtools: restart: additional-paths: src/main/resources/templates/user 默认开启热部署，可打开配置文件设置spring.devtools.restart.enable为false关闭 12345spring: devtools: restart: # false: 热部署关闭 enabled: false","link":"/2020/03/11/SpringBoot%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2/"},{"title":"SpringBoot场景启动器","text":"当我们使用SpringBoot搭建一个web项目的时候，并不需要我们单独导入spring-webmvc，spring-web的相关包和版本，仅仅一个spring-boot-starter-web启动器就解决了，这到底是为什么呢？ 首先新建一个SpringBoot的web项目，打开pom.xml 1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 发现所有的SpringBoot的项目都会依赖于spring-boot-starter-parent这个父项目，ctrl+左键进入，再进入spring-boot-dependencies 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;properties&gt; &lt;activemq.version&gt;5.15.6&lt;/activemq.version&gt; &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt; &lt;appengine-sdk.version&gt;1.9.66&lt;/appengine-sdk.version&gt; &lt;artemis.version&gt;2.4.0&lt;/artemis.version&gt; &lt;aspectj.version&gt;1.8.13&lt;/aspectj.version&gt; &lt;assertj.version&gt;3.9.1&lt;/assertj.version&gt; &lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt; &lt;bitronix.version&gt;2.1.4&lt;/bitronix.version&gt; &lt;build-helper-maven-plugin.version&gt;3.0.0&lt;/build-helper-maven-plugin.version&gt; &lt;byte-buddy.version&gt;1.7.11&lt;/byte-buddy.version&gt; &lt;caffeine.version&gt;2.6.2&lt;/caffeine.version&gt; &lt;cassandra-driver.version&gt;3.4.0&lt;/cassandra-driver.version&gt; &lt;classmate.version&gt;1.3.4&lt;/classmate.version&gt; &lt;commons-codec.version&gt;1.11&lt;/commons-codec.version&gt; &lt;commons-dbcp2.version&gt;2.2.0&lt;/commons-dbcp2.version&gt; &lt;commons-lang3.version&gt;3.7&lt;/commons-lang3.version&gt; &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt; &lt;commons-pool2.version&gt;2.5.0&lt;/commons-pool2.version&gt; &lt;couchbase-cache-client.version&gt;2.1.0&lt;/couchbase-cache-client.version&gt; &lt;couchbase-client.version&gt;2.5.9&lt;/couchbase-client.version&gt; &lt;derby.version&gt;10.14.2.0&lt;/derby.version&gt; &lt;dom4j.version&gt;1.6.1&lt;/dom4j.version&gt; &lt;dropwizard-metrics.version&gt;3.2.6&lt;/dropwizard-metrics.version&gt; &lt;ehcache.version&gt;2.10.5&lt;/ehcache.version&gt; &lt;ehcache3.version&gt;3.5.3&lt;/ehcache3.version&gt; &lt;elasticsearch.version&gt;5.6.12&lt;/elasticsearch.version&gt; &lt;embedded-mongo.version&gt;2.0.3&lt;/embedded-mongo.version&gt; &lt;exec-maven-plugin.version&gt;1.5.0&lt;/exec-maven-plugin.version&gt; &lt;flatten-maven-plugin.version&gt;1.0.1&lt;/flatten-maven-plugin.version&gt; &lt;flyway.version&gt;5.0.7&lt;/flyway.version&gt; &lt;freemarker.version&gt;2.3.28&lt;/freemarker.version&gt; &lt;git-commit-id-plugin.version&gt;2.2.5&lt;/git-commit-id-plugin.version&gt; &lt;glassfish-el.version&gt;3.0.0&lt;/glassfish-el.version&gt; &lt;groovy.version&gt;2.4.15&lt;/groovy.version&gt; &lt;gson.version&gt;2.8.5&lt;/gson.version&gt; &lt;h2.version&gt;1.4.197&lt;/h2.version&gt; &lt;hamcrest.version&gt;1.3&lt;/hamcrest.version&gt; &lt;hazelcast.version&gt;3.9.4&lt;/hazelcast.version&gt; &lt;hazelcast-hibernate5.version&gt;1.2.3&lt;/hazelcast-hibernate5.version&gt; &lt;hibernate.version&gt;5.2.17.Final&lt;/hibernate.version&gt; &lt;hibernate-jpa-2.1-api.version&gt;1.0.2.Final&lt;/hibernate-jpa-2.1-api.version&gt; &lt;hibernate-validator.version&gt;6.0.13.Final&lt;/hibernate-validator.version&gt; &lt;hikaricp.version&gt;2.7.9&lt;/hikaricp.version&gt; &lt;hsqldb.version&gt;2.4.1&lt;/hsqldb.version&gt; &lt;htmlunit.version&gt;2.29&lt;/htmlunit.version&gt; &lt;httpasyncclient.version&gt;4.1.4&lt;/httpasyncclient.version&gt; &lt;httpclient.version&gt;4.5.6&lt;/httpclient.version&gt; &lt;httpcore.version&gt;4.4.10&lt;/httpcore.version&gt; &lt;infinispan.version&gt;9.1.7.Final&lt;/infinispan.version&gt; &lt;influxdb-java.version&gt;2.9&lt;/influxdb-java.version&gt; &lt;jackson.version&gt;2.9.7&lt;/jackson.version&gt; &lt;janino.version&gt;3.0.10&lt;/janino.version&gt; &lt;javax-annotation.version&gt;1.3.2&lt;/javax-annotation.version&gt; &lt;javax-cache.version&gt;1.1.0&lt;/javax-cache.version&gt; &lt;javax-jaxb.version&gt;2.3.1&lt;/javax-jaxb.version&gt; &lt;javax-jms.version&gt;2.0.1&lt;/javax-jms.version&gt; &lt;javax-json.version&gt;1.1.3&lt;/javax-json.version&gt; &lt;javax-jsonb.version&gt;1.0&lt;/javax-jsonb.version&gt; &lt;javax-mail.version&gt;1.6.2&lt;/javax-mail.version&gt; &lt;javax-money.version&gt;1.0.3&lt;/javax-money.version&gt; &lt;javax-transaction.version&gt;1.2&lt;/javax-transaction.version&gt; &lt;javax-validation.version&gt;2.0.1.Final&lt;/javax-validation.version&gt; &lt;jaxen.version&gt;1.1.6&lt;/jaxen.version&gt; &lt;jaybird.version&gt;3.0.5&lt;/jaybird.version&gt; &lt;jboss-logging.version&gt;3.3.2.Final&lt;/jboss-logging.version&gt; &lt;jboss-transaction-spi.version&gt;7.6.0.Final&lt;/jboss-transaction-spi.version&gt; &lt;jdom2.version&gt;2.0.6&lt;/jdom2.version&gt; &lt;jedis.version&gt;2.9.0&lt;/jedis.version&gt; &lt;jersey.version&gt;2.26&lt;/jersey.version&gt; &lt;jest.version&gt;5.3.4&lt;/jest.version&gt; &lt;jetty.version&gt;9.4.12.v20180830&lt;/jetty.version&gt; &lt;jetty-el.version&gt;8.5.33&lt;/jetty-el.version&gt; &lt;jetty-jsp.version&gt;2.2.0.v201112011158&lt;/jetty-jsp.version&gt; &lt;jmustache.version&gt;1.14&lt;/jmustache.version&gt; &lt;jna.version&gt;4.5.2&lt;/jna.version&gt; &lt;joda-time.version&gt;2.9.9&lt;/joda-time.version&gt; &lt;johnzon.version&gt;1.1.10&lt;/johnzon.version&gt; &lt;johnzon-jsonb.version&gt;1.1.10&lt;/johnzon-jsonb.version&gt; &lt;jolokia.version&gt;1.5.0&lt;/jolokia.version&gt; &lt;jooq.version&gt;3.10.8&lt;/jooq.version&gt; &lt;jsonassert.version&gt;1.5.0&lt;/jsonassert.version&gt; &lt;json-path.version&gt;2.4.0&lt;/json-path.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;jtds.version&gt;1.3.1&lt;/jtds.version&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;junit-jupiter.version&gt;5.1.1&lt;/junit-jupiter.version&gt; &lt;junit-platform.version&gt;1.1.0&lt;/junit-platform.version&gt; &lt;kafka.version&gt;1.0.2&lt;/kafka.version&gt; &lt;kotlin.version&gt;1.2.51&lt;/kotlin.version&gt; &lt;lettuce.version&gt;5.0.5.RELEASE&lt;/lettuce.version&gt; &lt;liquibase.version&gt;3.5.5&lt;/liquibase.version&gt; &lt;log4j2.version&gt;2.10.0&lt;/log4j2.version&gt; &lt;logback.version&gt;1.2.3&lt;/logback.version&gt; &lt;lombok.version&gt;1.16.22&lt;/lombok.version&gt; &lt;mariadb.version&gt;2.2.6&lt;/mariadb.version&gt; &lt;maven-antrun-plugin.version&gt;1.8&lt;/maven-antrun-plugin.version&gt; &lt;maven-assembly-plugin.version&gt;3.1.0&lt;/maven-assembly-plugin.version&gt; &lt;maven-clean-plugin.version&gt;3.0.0&lt;/maven-clean-plugin.version&gt; &lt;maven-compiler-plugin.version&gt;3.7.0&lt;/maven-compiler-plugin.version&gt; &lt;maven-dependency-plugin.version&gt;3.0.2&lt;/maven-dependency-plugin.version&gt; &lt;maven-deploy-plugin.version&gt;2.8.2&lt;/maven-deploy-plugin.version&gt; &lt;maven-eclipse-plugin.version&gt;2.10&lt;/maven-eclipse-plugin.version&gt; &lt;maven-enforcer-plugin.version&gt;3.0.0-M2&lt;/maven-enforcer-plugin.version&gt; &lt;maven-failsafe-plugin.version&gt;2.21.0&lt;/maven-failsafe-plugin.version&gt; &lt;maven-help-plugin.version&gt;2.2&lt;/maven-help-plugin.version&gt; &lt;maven-install-plugin.version&gt;2.5.2&lt;/maven-install-plugin.version&gt; &lt;maven-invoker-plugin.version&gt;3.1.0&lt;/maven-invoker-plugin.version&gt; &lt;maven-jar-plugin.version&gt;3.0.2&lt;/maven-jar-plugin.version&gt; &lt;maven-javadoc-plugin.version&gt;3.0.1&lt;/maven-javadoc-plugin.version&gt; &lt;maven-resources-plugin.version&gt;3.0.2&lt;/maven-resources-plugin.version&gt; &lt;maven-shade-plugin.version&gt;2.4.3&lt;/maven-shade-plugin.version&gt; &lt;maven-site-plugin.version&gt;3.6&lt;/maven-site-plugin.version&gt; &lt;maven-source-plugin.version&gt;3.0.1&lt;/maven-source-plugin.version&gt; &lt;maven-surefire-plugin.version&gt;2.21.0&lt;/maven-surefire-plugin.version&gt; &lt;maven-war-plugin.version&gt;3.1.0&lt;/maven-war-plugin.version&gt; ...... &lt;/properties&gt; 发现原来spring-boot-denpendencies才是管理所有依赖版本号的地方，类似于版本管理中心，所以我们导入的依赖默认是不需要版本的 以spring-boot-starter-web启动器为例进入spring-boot-starter-web，可以发现spring-webmvc，spring-web等开发web项目必须的包，而版本号则交给spring-boot-denpendencies统一管理 1234567891011121314151617181920212223242526&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;","link":"/2020/03/11/SpringBoot%E5%9C%BA%E6%99%AF%E5%90%AF%E5%8A%A8%E5%99%A8/"},{"title":"SpringBoot整合JDBC","text":"连接数据库的方式有很多，比如Jpa（参考SpringBoot整合JPA），Mybatis（参考SpringBoot整合Mybatis），原生JDBC等，本文主要详细讲述借助JdbcTemplate来操作数据库 首先新建一个web工程，打开pom.xml引入相关依赖 123456789101112131415&lt;!--JDBC依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--mysql依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 配置数据库连接 123456spring: datasource: url: jdbc:mysql://localhost:3306/test_jdbc?serverTimezone=UTC username: root password: root driver-class-name: com.mysql.jdbc.Driver 新建表tb_user，添加一条数据 新建实体类User 12345678910111213141516171819202122232425262728293031public class User { private Integer id; private String lastName; private String email; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; }} 实现dao层，新建UserDao 123456789101112131415@Repositorypublic class UserDao { @Autowired JdbcTemplate jdbcTemplate; public List&lt;Map&lt;String, Object&gt;&gt; selectUser() { List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;select * from tb2_user&quot;); if (list.size() &gt; 0) { return list; } return null; }} 为了简单就省略service层，直接新建UserController 123456789101112@RestControllerpublic class Usercontroller { @Autowired UserDao userDao; @GetMapping(&quot;/user&quot;) public List&lt;Map&lt;String, Object&gt;&gt; insertUser() { List&lt;Map&lt;String, Object&gt;&gt; list = userDao.selectUser(); return list; }} 启动项目，浏览器输入localhost:8080/user，得到数据，整合成功","link":"/2020/03/11/SpringBoot%E6%95%B4%E5%90%88JDBC/"},{"title":"SpringBoot整合JPA","text":"SpringBoot整合JPA的详细教程 简介我们都知道一个概念ORM（Object Relational Mapping）对象关系映射，ORM的作用是在操作数据库之前，先把数据表与实体类关联起来，然后通过实体类的对象操作（增删改查）数据库表。所以，ORM是一个实现使用对象操作数据库的设计思想！！！ 通过这句话，我们知道JPA的作用就是通过对象操作数据库的，不用编写sql语句。 JPA和Hibernate、toplink的关系就像JDBC和mysql、Oracle驱动的关系一样，JPA是规范，Hibernate除了是ORM框架之外，它还是一种JPA的实现。而Spring Data JPA其实就是基于ORM框架封装了的Hibernate，可使得开发者用极简的代码即可实现对数据库的访问和操作，它提供了包括增删改查等常用功能，可以极大提高开发效率。 快速入门 新建一个web项目（可以参考我的上一篇博客SpringBoot初体验）打开pom.xml引入依赖1234567891011121314151617181920&lt;dependencies&gt; &lt;!--只要和数据库有链接就会有JDBC的依赖包，所以导入了JPA就有了JDBC的依赖包不需要再导入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--引入web依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--引入mysql依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 打开配置文件application.yml，添加数据库配置12345678910111213spring: datasource: url: jdbc:mysql://localhost:3306/jpa?serverTimezone=UTC username: root password: root driver-class-name: com.mysql.jdbc.Driver#能配置哪些属性在JpaProperties里面有绑定，参照即可 jpa: hibernate: #更新或者创建数据表结构 ddl-auto: update #控制台显示sql show-sql: true 添加实体类User1234567891011121314151617181920212223242526272829303132333435363738//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类(和数据表映射的类)@Table(name = &quot;tb2_user&quot;) //@Table 来制定和那个数据表对应；若省略则对应小写的userpublic class User { @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增 private Integer id; @Column(name = &quot;last_name&quot;, length = 50) //这是和数据表对应的一个列，大小50 private String lastName; @Column //省略：默认列名就是属性名 private String email; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; }} 添加接口类UserRepository继承JpaRepository123//继承JpaRepository&lt;User, Integer&gt; 完成对数据库的操作 &lt;实体类类名， 实体类主键的数据类型&gt;public interface UserRepository extends JpaRepository&lt;User, Integer&gt; {} 添加Controller层UserController123456789101112131415161718@RestControllerpublic class Usercontroller { //不需要添加@Bean注入容器， 因为UserRepository本身就是 JPARepository @Autowired UserRepository userRepository; @GetMapping(&quot;/user/{id}&quot;) public User findUserById(@PathVariable(&quot;id&quot;) Integer id) { return userRepository.findById(id).orElse(null); } @GetMapping(&quot;/user&quot;) public User insertUser(User user) { User user1 = userRepository.save(user); return user1; }} 新建数据库jpa 启动项目会自动生成表tb2_user 浏览器输入localhost:8080/user?lastName=zhangsan 添加User对象成功，并查看数据库表 最后浏览器输入localhost:8080/user/1 得到json对象，测试成功","link":"/2020/03/11/SpringBoot%E6%95%B4%E5%90%88JPA/"},{"title":"SpringBoot整合Lombok及使用","text":"Lombok项目是一个Java库，它会自动插入您的编辑器和构建工具中，从而为您的Java增光添彩。永远不要再编写另一个getter或equals方法，带有一个注释的类将具有功能全面的生成器，自动执行日志记录变量等等。 下载和设置首先打开IDEA中设置，找到plugin，搜索lombok，点击install下载并应用，最后记得重启IDEA。或者你也可以官网下载安装https://projectlombok.org/download 添加注解支持 Annotation Processors 在 [maven仓库] 搜索下载 并添加Lombok依赖到pom.xml 123456&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt;&lt;!--可以不加版本号--&gt;&lt;/dependency&gt; 注解介绍12345678910111213@Data : 自动生成set/get方法，toString方法，equals方法，hashCode方法，不带参数的构造方法 @NonNull : 让你不在担忧并且爱上NullPointerException @CleanUp : 自动资源管理：不用再在finally中添加资源的close方法 @Setter/@Getter : 自动生成set和get方法 @ToString : 自动生成toString方法 @EqualsAndHashcode : 从对象的字段中生成hashCode和equals的实现 @NoArgsConstructor/@RequiredArgsConstructor/@AllArgsConstructor 自动生成构造方法 @Value : 用于注解final类 @Builder : 产生复杂的构建器api类，可以让你以下面显示的那样调用你的代码，来初始化你的实例对象@SneakyThrows : 异常处理（谨慎使用） @Synchronized : 同步方法安全的转化 @Log : 支持各种logger对象，使用时用对应的注解，如：@Log4 @Data和@Log注解用的较多未使用Lombok管理时实体类User 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class User { private Integer id; private String name; private String pwd; private Double score; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } public Double getScore() { return score; } public void setScore(Double score) { this.score = score; } public User() { } public User(Integer id, String name, String pwd, Double score) { this.id = id; this.name = name; this.pwd = pwd; this.score = score; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; return Objects.equals(id, user.id) &amp;&amp; Objects.equals(name, user.name) &amp;&amp; Objects.equals(pwd, user.pwd) &amp;&amp; Objects.equals(score, user.score); } @Override public int hashCode() { return Objects.hash(id, name, pwd, score); } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, name='&quot; + name + '\\'' + &quot;, pwd='&quot; + pwd + '\\'' + &quot;, score=&quot; + score + '}'; }} 添加@Data后 1234567@Datapublic class User { private Integer id; private String name; private String pwd; private Double score;} 然后实例化User之后，里面所有方法都可以使用，添加UserController 12345678910111213141516171819@RestController@Log4j2public class UserController { //private final Logger logger = LogManager.getLogger(this.getClass()); @GetMapping(&quot;/test&quot;) public User testUser() { User user = new User(); user.setName(&quot;zhangsan&quot;); user.setPwd(&quot;123&quot;); user.setScore(2.0D); System.out.println(user.toString()); log.info(&quot;info excute&quot;); log.warn(&quot;warn excute&quot;); return user; }} 在applicaiton.properties中添加日志输出位置 1logging.file = logs/spring-boot-test-lombok.log 浏览器输入localhost:8080/test 补充：在User类上添加@Builder 12345678User user = User.builder() .id(1) .name(&quot;aaa&quot;) .pwd(&quot;bbb&quot;) .score(&quot;bbb&quot;) .build();System.out.println(user); 更多内容请访问 我的个人博客","link":"/2020/03/18/SpringBoot%E6%95%B4%E5%90%88Lombok%E5%8F%8A%E4%BD%BF%E7%94%A8/"},{"title":"SpringBoot整合Mybatis注解版","text":"SpringBoot+Mybatis+druid整合详细过程，这里使用的是druid连接池（亦可以使用hikari连接池，参考SpringBoot整合hikari），具体参数配置请参考我的上一篇博客SpringBoot整合druid 项目准备首先新建一个SpringBoot的web项目，选择Spring Initializr（用来初始化一个Spring boot 的项目） 然后填写项目坐标，自行修改 最后选择要添加的组件web，Mybatis，mysql新建成功 配置打开pom.xml文件 12345678910111213141516171819202122232425262728 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!--mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加druid依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入log4j，因为driud添加的拓展插件为log4j--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 打开配置文件application.yml添加具体属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445========================#数据源基本配置spring: datasource: username: root password: root driver-class-name: com.mysql.jdbc.Driver# 时区配置错误就添加 serverTimezone = UTC url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC #druid增加的配置 type: com.alibaba.druid.pool.DruidDataSource=========================以下配置酌情处理=========== # 初始化连接池个数 initialSize: 5 # 最小连接池个数 minIdle: 5 # 最大连接池个数 max-active: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测 timeBetweenEvictionRunsMillis: 60000 # 最小生存的时间 minEvictableIdleTimeMillis: 300000 # 用来检测连接是否有效的sql，要求是一个查询语句。 # 如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用 validationQuery: SELECT 1 FROM DUAL # 建议配置为true，不影响性能，并且保证安全性。 # 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 testWhileIdle: true # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testOnBorrow: false # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 通过别名的方式配置扩展插件，多个英文逗号分隔，常用的插件有： # 监控统计用的filter:stat # 日志用的filter:log4j # 防御sql注入的filter:wall filters: stat,wall,log4j # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 # 合并多个DruidDataSource的监控数据 useGlobalDataSourceStat: true 添加配置类MyBatisConfig开启驼峰命名 123456789101112public class MybatisConfig { @Bean public ConfigurationCustomizer configurationCustomizer() { return new ConfigurationCustomizer() { @Override public void customize(Configuration configuration) { configuration.setMapUnderscoreToCamelCase(true); //开启驼峰 } }; }} 添加实体类Department 1234567891011121314151617181920public class Department { private Integer id; private String departmentName; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getDepartmentName() { return departmentName; } public void setDepartmentName(String departmentName) { this.departmentName = departmentName; }} 打开数据库管理工具新建名为mybatis的数据库，执行Department类对应sql脚本 1234567891011SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for department-- ----------------------------DROP TABLE IF EXISTS `department`;CREATE TABLE `department` ( `id` int(11) NOT NULL AUTO_INCREMENT, `department_name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 添加接口DepartmentMapper，使用注解增删改查，这里只演示insert和select 12345678910public interface DepartmentMapper { @Select(&quot;select * from department where id=#{id}&quot;) Department getDeptById(Integer id); //使用自动生成的主键，并告诉是那个属性是封装主键的 @Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;) @Insert(&quot;insert into department(department_name) values(#{departmentName})&quot;) int insertDept(Department department);} 在启动类上添加@MapperScan扫描mapper包 123456789@MapperScan(value = &quot;com.springboot.mapper&quot;)@SpringBootApplicationpublic class SpringBootDataMybatisApplication { public static void main(String[] args) { SpringApplication.run(SpringBootDataMybatisApplication.class, args); }} 添加DeptController类 1234567891011121314151617@RestControllerpublic class DeptController { @Autowired private DepartmentMapper departmentMapper; @GetMapping(&quot;/dept/{id}&quot;) public Department getDepartment(@PathVariable(&quot;id&quot;) Integer id) { return departmentMapper.getDeptById(id); } @GetMapping(&quot;/insert&quot;) public Department insertDept(Department department) { departmentMapper.insertDept(department); return department; }} 启动项目，在浏览器输入localhost：8080/insert?departmentName=huawei，新增数据成功 然后再输入localhost:8080/dept/1，获取departmentName=huawei的数据 至此整合成功","link":"/2020/03/11/SpringBoot%E6%95%B4%E5%90%88Mybatis%E6%B3%A8%E8%A7%A3%E7%89%88/"},{"title":"SpringBoot整合Druid","text":"Druid功能强大且全面 Druid是Alibaba开源的的数据库连接池。Druid能够提供强大的监控功能，比如sql监控、URI监控、Session监控等，在功能、性能、扩展性方面都超过其他例如DBCP、C3P0等连接池，而且Druid是一个开源项目，源码托管在github上，地址是 https://github.com/alibaba/druid 配置打开pom.xml引入依赖，可在https://mvnrepository.com/tags/maven搜索druid下载，建议下载alibaba提供的 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--引入mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--导入德鲁伊--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt;&lt;!--导入log4j，因为driud添加的拓展插件为log4j--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 修改配置文件application.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445========================#数据源基本配置spring: datasource: username: root password: root driver-class-name: com.mysql.jdbc.Driver# 时区配置错误就添加 serverTimezone = UTC url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC #druid增加的配置 type: com.alibaba.druid.pool.DruidDataSource=========================以下配置酌情处理=========== # 初始化连接池个数 initialSize: 5 # 最小连接池个数 minIdle: 5 # 最大连接池个数 max-active: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测 timeBetweenEvictionRunsMillis: 60000 # 最小生存的时间 minEvictableIdleTimeMillis: 300000 # 用来检测连接是否有效的sql，要求是一个查询语句。 # 如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用 validationQuery: SELECT 1 FROM DUAL # 建议配置为true，不影响性能，并且保证安全性。 # 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 testWhileIdle: true # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testOnBorrow: false # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 通过别名的方式配置扩展插件，多个英文逗号分隔，常用的插件有： # 监控统计用的filter:stat # 日志用的filter:log4j # 防御sql注入的filter:wall filters: stat,wall,log4j # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 # 合并多个DruidDataSource的监控数据 useGlobalDataSourceStat: true 添加配置类DruidConfig 12345678910111213141516171819202122232425262728293031323334353637@Configurationpublic class DruidConfig { @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druid() { return new DruidDataSource(); } //配置Druid的监控 现在可以在application.yml配置文件中配置了 @Bean public ServletRegistrationBean statViewServlet() { ServletRegistrationBean bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), &quot;/druid/*&quot;); Map&lt;String, String&gt; initMap = new HashMap&lt;&gt;();//设置账号密码 initMap.put(&quot;loginUsername&quot;, &quot;admin&quot;); initMap.put(&quot;loginPassword&quot;, &quot;123456&quot;); initMap.put(&quot;allow&quot;, &quot;&quot;);//默认允许所有地址访问// initMap.put(&quot;deny&quot;, &quot;192.168.3.22&quot;); 拒绝地址访问 bean.setInitParameters(initMap); return bean; } //配置web监控的 filter @Bean public FilterRegistrationBean webStatFilter() { FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String, String&gt; initMap = new HashMap&lt;&gt;(); //排除js脚本文件，css样式 initMap.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(initMap); bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean; }} 启动项目，浏览器输入localhost:8080/druid，输入用户名和密码为admin，123456进入访问页面成功 至此就能在图形化界面查看SQL监控，数据源等功能","link":"/2020/03/11/SpringBoot%E6%95%B4%E5%90%88druid/"},{"title":"SpringBoot整合ehcache","text":"EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认CacheProvider。 简介Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。 ehcache 和 redis 比较ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。redis是通过socket访问到缓存服务，效率比ecache低，比数据库要快很多，处理集群和分布式缓存方便，有成熟的方案。如果是单个应用或者对缓存访问要求很高的应用，用ehcache。如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。 注解Spring对缓存的支持类似于对事务的支持，相当于定义了切点，然后使用Aop技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。主要注解：@Cacheable表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。可以使用key属性来指定key的生成规则。 @CachePut与@Cacheable不同，@CachePut不仅会缓存方法的结果，还会执行方法的代码段。它支持的属性和用法都与@Cacheable一致。一个缓存后就不执行代码了，一个还要执行) @CacheEvict与@Cacheable功能相反，@CacheEvict表明所修饰的方法是用来删除失效或无用的缓存数据。value：缓存位置名称，不能为空，同上key：缓存的key，默认为空，同上condition：触发条件，只有满足条件的情况才会清除缓存，默认为空，支持SpELallEntries：true表示清除value中的全部缓存，默认为false 准备准备好新建数据库和表结构，并插入数据，sql脚本如下 12345678910111213141516171819202122232425262728293031323334353637383940/*SQLyog Ultimate v12.08 (64 bit)MySQL - 5.6.42 : Database - spring_cache**********************************************************************//*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=''*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;CREATE DATABASE /*!32312 IF NOT EXISTS*/`spring_cache` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;USE `spring_cache`;/*Table structure for table `employee` */DROP TABLE IF EXISTS `employee`;CREATE TABLE `employee` ( `id` int(11) NOT NULL AUTO_INCREMENT, `lastName` varchar(255) DEFAULT NULL, `email` varchar(255) DEFAULT NULL, `gender` int(2) DEFAULT NULL, `d_id` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;/*Data for the table `employee` */insert into `employee`(`id`,`lastName`,`email`,`gender`,`d_id`) values (1,'zhangsan','1234@qq.com',1,1);/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; 搭建工程SpringBoot + 注解版Mybatis + Mysqlpom.xml文件依赖如下 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置文件application.yml中数据库连接和开启驼峰命名 123456789101112131415161718spring: datasource: url: jdbc:mysql://localhost:3306/spring_cache?serverTimezone=UTC driver-class-name: com.mysql.cj.jdbc.Driver username: root password: root #开启驼峰命名法mybatis: configuration: map-underscore-to-camel-case: true #开启日志打印#com.eh.springbootcache: 目录logging: level: com: eh: springbootcache: mapper: debug 添加实体类employee 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Employee { private Integer id; private String lastName; private Integer gender; private String email; private Integer dId; public Employee() { } public Employee(Integer id, String lastName, Integer gender, String email, Integer dId) { this.id = id; this.lastName = lastName; this.gender = gender; this.email = email; this.dId = dId; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public Integer getGender() { return gender; } public void setGender(Integer gender) { this.gender = gender; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Integer getdId() { return dId; } public void setdId(Integer dId) { this.dId = dId; }} 添加dao层EmployeeMapper 1234public interface EmployeeMapper { @Select(&quot;SELECT * FROM employee WHERE id = #{id}&quot;) public Employee getEmpById(Integer id);} 添加service层 12345678910111213@Servicepublic class EmployeeService { @Resource EmployeeMapper employeeMapper; //将方法的运行结果进行缓存，再次查询就可以从缓存中取,不用调用该方法 @Cacheable(value = &quot;{emp}&quot;, condition = &quot;#id&gt;0&quot;) public Employee getEmp(Integer id) { System.out.println(&quot;查询员工&quot; + id); return employeeMapper.getEmpById(id); }} 添加EmployeeController 1234567891011@RestControllerpublic class EmployeeController { @Resource private EmployeeService employeeService; @GetMapping(&quot;/emp/{id}&quot;) public Employee getEmp(@PathVariable(&quot;id&quot;) Integer id) { return employeeService.getEmp(id); }} 开启注解缓存，扫描EmployeeMapper所在包 12345678910@MapperScan(&quot;com.eh.springbootcache.mapper&quot;)@SpringBootApplication@EnableCaching //开启基于注解的缓存public class SpringBootCacheApplication { public static void main(String[] args) { SpringApplication.run(SpringBootCacheApplication.class, args); }} 浏览器输入localhost:8080/emp/1第一次查询数据，console输出如下 清空console，第二次则使用缓存，显示结果，如下 @CachePut和@CacheEvict的用法可自行测试","link":"/2020/03/11/SpringBoot%E6%95%B4%E5%90%88ehcache/"},{"title":"SpringBoot整合hikari","text":"hikari号称史上最快连接池，也是SpringBoot默认推荐的连接池 为什么hikari连接池如此的快官网说： 自定义数组类型（FastStatementList）代替ArrayList：避免每次get()调用都要进行range check，避免调用remove()时的从头到尾的扫描； 优化代理和拦截器：减少代码，例如HikariCP的Statement proxy只有100行代码； 字节码精简：优化代码，直到编译后的字节码最少，这样，CPU缓存可以加载更多的程序代码； 自定义集合类型（ConcurrentBag）：提高并发读写的效率；由此可见，相比于其他链接池C3P0，DBCP“性能王”hikari的优势很明显，再加上它130kb的小身形，日后前途不可限量。 配置首先新建一个SpringBoot的web项目，详情请参考我的上一篇博文SpringBoot初体验，然后配置application.yml文件指定连接池类型为hikari 123456789101112131415161718192021222324# 数据库配置spring.datasource.url = jdbc:mysql://localhost:3306/hikariTest?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsespring.datasource.username = rootspring.datasource.password = rootspring.datasource.driverClassName = com.mysql.jdbc.Driver#指定连接池类型为hikarispring.datasource.type=com.zaxxer.hikari.HikariDataSource# 连接池最大连接数，默认是10spring.datasource.hikari.maximum-pool-size=50# 此属性控制从池返回的连接的默认自动提交行为,默认值：truespring.datasource.hikari.auto-commit=true#连接将被测试活动的最大时间量spring.datasource.hikari.validationTimeout=10000 # 连接池连接的最长生命周期，默认30分钟spring.datasource.hikari.max-lifetime=1800000# 连接超时时间,默认30秒spring.datasource.hikari.connection-timeout=30000#如果您的驱动程序支持JDBC4，不要设置此属性spring.datasource.hikari.connection-test-query=SELECT 1# 最小空闲连接数量spring.datasource.hikari.minimum-idle=10# 空闲连接存活最大时间，默认10分钟spring.datasource.hikari.idle-timeout=180000 pom.xml中添加依赖包 12345&lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt; 启动项目看到com.zaxxer.hikari.HikariDataSource：Start completed即连接成功","link":"/2020/03/11/SpringBoot%E6%95%B4%E5%90%88hikari/"},{"title":"SpringBoot整合thymeleaf","text":"好用的模板引擎thymeleaf thymeleaf简介Spring Boot提供了多种模板引擎的默认配置支持，但嵌入式容器JSP有限制，2010年后Velocity停止更新，所以这JSP与Velocity两个不建议使用。而Thymeleaf与SpringMVC的视图技术，及SpringBoot的自动化配置集成非常完美，几乎没有任何成本，你只用关注Thymeleaf的语法即可。 Thymeleaf的特点 动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。和SpringBoot整合 新建SpringBoot项目（可参考我的上一篇博客SpringBoot初体验），打开pom.xml，添加thymeleaf依赖 12345678910111213&lt;dependencies&gt; &lt;!--web容器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--前端模板thymeleaf依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 打开配置文件application,yml（application.properties），关闭thymeleaf缓存 新建HelloWorldController类，返回hello页面 templates目录下新建hello.html 打开SpringBootThymeleafApplication类启动项目 浏览器中输入localhost:8080/hello，访问成功","link":"/2020/03/11/SpringBoot%E6%95%B4%E5%90%88thymeleaf/"},{"title":"SpringBoot自定义starter","text":"为什么需要自制启动器？因为极大的提高了代码的高可用，比如在我们的日常开发工作中，如果一个工程需要复用一些独立于业务之外的配置模块时候，我们将这些可独立于业务代码之外的功配置模块封装成一个个starter，复用的时候只需要将其在pom中引用依赖即可 搭建工程 新建一个空工程 创建一个普通的maven工程hello-spring-boot-starter，这个工程里面不写业务逻辑，只是一个空的JAR文件用来依赖引入hello-spring-boot-autoconfig（下一步创建），而对外在测试类中需要引用我们自定义的启动器，只需引入hello-spring-boot-starter即可。 建立一个实现业务逻辑的工程hello-spring-boot-autoconfig，这种的命名方式是因为SpringBoot提供的starter以spring-boot-starter-xxx的方式命名的，而官方建议自定义的starter使用xxx-spring-boot-starter命名规则，以区分SpringBoot生态提供的starter。 pom.xml如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.hello.starter&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter-autoconfig&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;hello-spring-boot-starter-autoconfig&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 在hello-spring-boot-starter工程的pom.xml中引入hello-spring-boot-autoconfig依赖 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.hello.starter&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!--启动器里面只做依赖引入,引入hello-spring-boot-autoconfig--&gt; &lt;!--别人要用我们自定义的启动器，只需要引入hello-spring-boot-starter--&gt; &lt;dependency&gt; &lt;groupId&gt;com.hello.starter&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter-autoconfig&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 开始编码删掉主程序和配置文件还有test目录 在hello-spring-boot-starter-autoconfig项目下新建HelloProperties实体类映射配置信息，用@ConfigurationProperties注解可以完成将application.yml配置文件内的有规则的配置参数映射到实体内的field内 123456789101112131415161718192021@ConfigurationProperties(prefix = &quot;hello.starter&quot;)public class HelloProperties { private String prefix; private String suffix; public String getPrefix() { return prefix; } public void setPrefix(String prefix) { this.prefix = prefix; } public String getSuffix() { return suffix; } public void setSuffix(String suffix) { this.suffix = suffix; }} 添加service类，通过sayHello方法完成对helloProperties的属性读取 12345678910111213141516171819public class HelloService { HelloProperties helloProperties; public HelloProperties getHelloProperties() { return helloProperties; } public void setHelloProperties(HelloProperties helloProperties) { this.helloProperties = helloProperties; }/*此处业务逻辑可更换*/ public String sayHello(String name) { return helloProperties.getPrefix() + &quot;-&quot; + name + &quot;-&quot; + helloProperties.getSuffix(); }} 添加配置类HelloServiceAutoConfiguration，如果你用来测试的工程是web工程，那么在测试工程启动的时候会自动读取此配置类 123456789101112131415@Configuration@ConditionalOnWebApplication //需要是web应用，此处的配置才生效@EnableConfigurationProperties(HelloProperties.class) //属性文件生效public class HelloServiceAutoConfiguration { @Autowired HelloProperties helloProperties; @Bean public HelloService helloService() { HelloService helloService = new HelloService(); helloService.setHelloProperties(helloProperties); return helloService; }} resources目录下新建META-INF文件夹，然后创建spring.factories文件，添加如下代码，读取配置类HelloServiceAutoConfiguration 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.hello.starter.HelloServiceAutoConfiguration 安装因为hello-spring-boot-starter依赖于hello-spring-boot-autoconfig所以先安装xxx-autoconfig，再安装xxx-starter 安装之前，记得删除pom文件中的 1234567891011121314151617181920212223&lt;!--删除，因为前面已经删除了test类，不需要了--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--记得删除，不然打包不成功--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 测试新建一个用于测试的web工程hello-spring-boot-08-test，记得选中web组件 在pom.xml中引入启动器依赖 123456&lt;!--引入自定义的starter：hello-spring-boot-starter--&gt; &lt;dependency&gt; &lt;groupId&gt;com.hello.starter&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 打开配置文件application，添加前缀prefix，和后缀suffix 12hello.starter.prefix=2020hello.starter.suffix=come on 添加HelloController测试 1234567891011@RestControllerpublic class HelloController { @Autowired HelloService helloService; @GetMapping(&quot;/hello&quot;) public String hello() { return helloService.sayHello(&quot;中国&quot;); }} 启动项目，浏览器输入localhost:8080/hello，返回结果，自制starter测试成功","link":"/2020/03/11/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/"},{"title":"SpringBoot集成Spring Security(1)-初体验","text":"学习Spring Security之前我们需要先了解些基本概念 什么是认证为了保护系统的隐私数据和资源，判断一个用户的身份合法性的过程就是认证，比如现在账号密码登录，扫描二维码，指纹认证，人脸识别其实都包含了认证过程 什么是授权授权是通过认证的用户根据用户的权限来控制用户访问资源的过程，比如支付宝使用红包功能必须要绑定银行卡，点外卖必须添加家庭住址 简介Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它是用于保护基于Spring的应用程序的实际标准，致力于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring Security的真正强大之处在于可以轻松扩展以满足自定义要求 初体验新建SpringBoot的Web工程，在pom.xml中添加web和Spring Security依赖 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 新建配置类SecurityConfig重写configure(HttpSecurity http)和configure(WebSecurity web) 1234567891011121314151617181920212223@Configuration //配置类@EnableWebSecurity //开启SpringSecurity认证授权public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() //放行主路径 .anyRequest().authenticated() //其他的请求全部经过验证 .and() .logout().permitAll() //允许任意权限访问注销页面 .and() .formLogin(); //允许表单登录 http.csrf().disable(); } @Override public void configure(WebSecurity web) throws Exception { //忽略静态资源 web.ignoring().antMatchers(&quot;/js/**&quot;, &quot;/css/**&quot;, &quot;/images/**&quot;); }} 添加测试类TestController 12345678910111213@RestControllerpublic class TestController { @GetMapping(&quot;/&quot;) public String home() { return &quot;hello spring boot&quot;; } @GetMapping(&quot;/hello&quot;) public String hello() { return &quot;hello world&quot;; }} 启动项目，浏览器输入localhost:8080 结果如下，没有被拦截 再次输入localhost:8080/hello，此时被Security拦截，跳转到登陆页面 更多内容请访问 我的个人博客","link":"/2020/03/11/SpringBoot%E9%9B%86%E6%88%90Spring-Security%EF%BC%881%EF%BC%89-%E5%88%9D%E4%BD%93%E9%AA%8C/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"插件","slug":"插件","link":"/tags/%E6%8F%92%E4%BB%B6/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"注解","slug":"注解","link":"/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"热部署","slug":"热部署","link":"/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/"},{"name":"starter","slug":"starter","link":"/tags/starter/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"JPA","slug":"JPA","link":"/tags/JPA/"},{"name":"Lombok","slug":"Lombok","link":"/tags/Lombok/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"},{"name":"Druid","slug":"Druid","link":"/tags/Druid/"},{"name":"ehcache","slug":"ehcache","link":"/tags/ehcache/"},{"name":"hikari","slug":"hikari","link":"/tags/hikari/"},{"name":"thymeleaf","slug":"thymeleaf","link":"/tags/thymeleaf/"},{"name":"SpringSecurity","slug":"SpringSecurity","link":"/tags/SpringSecurity/"}],"categories":[{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/categories/SpringBoot/"}]}